package MOD_CCA {

    import oracles {
        KEMGEN() -> Bits(100),
        ENCAPS() -> Bits(400),
        DECAPS(ek: Bits(400)) -> Bits(256),
        ENC(m: Bits(*)) -> Bits(*),
        DEC(c: Bits(*)) -> Bits(*),
        DEM_DEC(k: Bits(256), c: Bits(*) /* ciphertext length */) -> Bits(*),
    }

    state {
        pk: Maybe(Bits(100)),
        c: Maybe((Bits(400),Bits(*))),
        ek: Maybe(Bits(400)),
        em: Maybe(Bits(*))
    }

    oracle PKGEN() -> Bits(100) {
        assert (pk == None);
        pk1 <- invoke KEMGEN();
        pk <- Some(pk1);
        return pk1;
    }

    oracle PKENC(m: Bits(*)) -> (Bits(400),Bits(*)) {
        assert (pk != None as Bits(100));
        assert (c == None);
        ek1 <- invoke ENCAPS();
        ek <- Some(ek1);
        em1 <- invoke ENC(m);
        em <- Some(em1);
        c1 <- (ek1, em1);
        c <- Some(c1);
        return c1;
    }

    oracle PKDEC(ek_ctxt: (Bits(400),Bits(*))) -> Bits(*) {
        assert (pk != None as Bits(100));
        assert (Unwrap(c) != ek_ctxt);
        (encapsk, ctxt) <- parse ek_ctxt;
        if (encapsk == Unwrap(ek)) {
            m <- invoke DEC(ctxt);
        } else {
            k <- invoke DECAPS(encapsk);
            m <- invoke DEM_DEC(k, ctxt);
        }
        return m;
    }
}