package MON_CCA {
    params {
        b: Bool,
        len: fn Bits(*) -> Integer,
        zeros: fn Integer -> Bits(*),
    }

    import oracles {
        GEN() -> (Bits(100), Bits(1000)),
        ENC(pk: Bits(100), m: Bits(*)) -> (Bits(400),Bits(*),Bits(3000)) /* ciphertext type */,
        DEC(sk: Bits(1000), c: (Bits(400),Bits(*)) /* ciphertext type */) -> Bits(*),
    }

    state {
        pk: Maybe(Bits(100)),
        sk: Maybe(Bits(1000)),
        c: Maybe((Bits(400),Bits(*)))
    }

    oracle PKGEN() -> Bits(100) {
        assert (sk == None);
        pk_sk <- invoke GEN();
        (pk1, sk1) <- parse pk_sk;
        pk <- Some(pk1);
        sk <- Some(sk1);
        return pk1;
    }

    oracle PKENC(m: Bits(*)) -> (Bits(400),Bits(*)) {
        assert (pk != None as Bits(100));
        assert (c == None);
        if b {
            c1 <- invoke ENC(Unwrap(pk), zeros(len(m)));
        } else {
            c1 <- invoke ENC(Unwrap(pk), m);
        }
        (ek, c2, r) <- parse c1;
        c <- Some((ek, c2));
        return (ek, c2);
    }

    oracle PKDEC(ek_ctxt: (Bits(400),Bits(*))) -> Bits(*) {
        assert (sk != None as Bits(1000));
        assert (Unwrap(c) != ek_ctxt);
        m <- invoke DEC(Unwrap(sk), ek_ctxt);
        return m;
    }
}