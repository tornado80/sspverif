package Key {
    params {
        /* b: Bool, */
        /* n: Integer, /* name of the key, see README */
        /* l: Integer, /* level */
        handle_alg: fn Bits(*) -> Integer, /* returns the algorithm identifier of the given handle */
        key_alg: fn Bits(*) -> Integer, /* returns the algorithm identifier of the given key */
        tag: fn Integer, Bits(*) -> Bits(*), /* tags the given key with the given algorithm identifier */
        untag: fn Bits(*) -> Bits(*), /* untags the given key and returns a raw key */
        name: fn Bits(*) -> Integer, /* returns the name of the given handle */
        level: fn Bits(*) -> Integer, /* returns the level of the given handle */
        zeros: fn Integer -> Bits(*), /* returns an all zeros bitstring of the given length */
        len_alg: fn Integer -> Integer, /* returns the length of keys of the given algorithm identifier */
        len_key: fn Bits(*) -> Integer /* returns the length of the given key */
    }

    state {
        K_dh: Table(Bits(*), (Bits(*), Bool)),
        K: Table((Integer, Integer, Bits(*)), (Bits(*), Bool)) /* maps (name, level, handle) to (key, honesty bit) */
    }

    import oracles {
        GET_KEY_PACKAGE_IDEALIZATION_PARAMETER(n: Integer, l: Integer) -> Bool,
        SAMPLE(n: Integer) -> Bits(*),
        UNQ(n: Integer, h: Bits(*), hon: Bool, k: Bits(*)) -> Bits(*),
        Q(n: Integer, h: Bits(*)) -> Maybe(Bits(*)),
        IS_DH_KEY(n: Integer) -> Bool,
        IS_PSK(n: Integer) -> Bool,
        IS_0salt_HANDLE(h: Bits(*)) -> Bool,
        IS_0ikm_HANDLE(h: Bits(*)) -> Bool,
        IS_noPSK_HANDLE(h: Bits(*)) -> Bool,
        IS_noDH_HANDLE(h: Bits(*)) -> Bool,
    }

    oracle SET(n: Integer, l: Integer, h: Bits(*), hon: Bool, ks: Bits(*)) -> Bits(*) {
        assert (name(h) == n);
        assert (level(h) == l);
        assert (key_alg(ks) == handle_alg(h));
        k <- untag(ks);
        len_h <- len_alg(handle_alg(h));
        assert (len_h == len_key(k));

        q_h <- invoke Q(n, h);
        if (q_h != None as Bits(*)) {
            return Unwrap(q_h);
        }
        b <- invoke GET_KEY_PACKAGE_IDEALIZATION_PARAMETER(n, l);
        if b {
            if hon {
                k <- invoke SAMPLE(len_h);
            }
        }
        
        /*
        unq_h <- invoke UNQ(n, h, hon, k);
        if (h != unq_h) {
            return unq_h;
        }
        */
        is_dh_key <- invoke IS_DH_KEY(n);
        if is_dh_key {
            K_dh[h] <- Some((k, hon));
        } else {
            K[(n, l, h)] <- Some((k, hon));
        }
        return h;
    }

    oracle GET(n: Integer, l: Integer, h: Bits(*)) -> (Bits(*), Bool) {
        is_dh_key <- invoke IS_DH_KEY(n);
        if is_dh_key {
            is_noDH_handle <- invoke IS_noDH_HANDLE(h);
            if (is_noDH_handle and (K_dh[h] == None)) {
                /* initialization of noDH keys */
                K_dh[h] <- Some((zeros(len_alg(handle_alg(h))), false));
            }
            assert (K_dh[h] != None as (Bits(*), Bool));
            (ks, hon) <- parse Unwrap(K_dh[h]);
            k <- tag(handle_alg(h), ks);
            return (k, hon);
        }
        is_0salt_handle <- invoke IS_0salt_HANDLE(h);
        if is_0salt_handle {
            ks <- zeros(1);
            k <- tag(handle_alg(h), ks);
            return (k, false);
        }
        is_0ikm_handle <- invoke IS_0ikm_HANDLE(h);
        if is_0ikm_handle {
            ks <- zeros(len_alg(handle_alg(h)));
            k <- tag(handle_alg(h), ks);
            return (k, false);
        }
        is_psk <- invoke IS_PSK(n);
        is_noPSK_handle <- invoke IS_noPSK_HANDLE(h);
        if (is_psk and is_noPSK_handle and (K[(n, l, h)] == None)) {
            /* initialization of noPSK keys */
            K[(n, l, h)] <- Some((zeros(len_alg(handle_alg(h))), false));
        }
        assert (K[(n, l, h)] != None as (Bits(*), Bool));
        (ks, hon) <- parse Unwrap(K[(n, l, h)]);
        k <- tag(handle_alg(h), ks);
        return (k, hon);
    }
}