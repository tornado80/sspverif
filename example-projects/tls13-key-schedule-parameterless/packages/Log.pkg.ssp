package Log {
    /*
    types {
        Handle: Bits(*)
    }
    */

    params {
        /* pattern: Integer, /* pattern see README (shortly; Z: 0, A: 1, D: 2, F: 3) */
        /* mapping: Integer, /* mapping see README (shortly; 0: 0, 1: 1, inf: 2) */
        level: fn Bits(*) -> Maybe(Integer) /* returns the level of the given handle */
    }

    /*
    level(mk_dh_handle(X, Y)) = 0
    level(mk_xtr_handle(n, h1, h2)) = 1 + level(h1)
    */

    /* We need to show why choosing the first handle with the same key as in inverse of the key is okay */
    /* Review and illustrate the Log^Zinf recognizing collision and Map changes the mapping with an example attack scenario*/
    state {
        ReturnPoint: Integer,
        LogSetCheckpoint: Integer,
        Log: Table((Integer, Bits(*)), (Bits(*), Bool, Bits(*))), /* maps (name, handle) to (mapped handle, honesty bit, key) */
        Seen: Table((Integer, Bits(*)), Bool), /* indicates whether the (name, key) was assigned before */
        LogInverseDishonest: Table((Integer, Bits(*)), Bits(*)), /* maps (name, key) to first dishonest handle */
        LogInverseDishonestLevelZero: Table(Bits(*), Bits(*)), /* maps psk key to first dishonest handle in level zero */
        LogInverseDishonestLevelNonZero: Table(Bits(*), Bits(*)), /* maps psk key to first dishonest handle in nonzero level */
        J: Table(Bits(*), Bool) /* indicates whether the key was mapped before */
    }

    import oracles {
        GET_LOG_PACKAGE_PARAMETERS(n: Integer) -> (Integer, Integer),
        IS_INFINITY_MAPPING(mapping: Integer) -> Bool,
        IS_1_MAPPING(mapping: Integer) -> Bool,
        IS_A_PATTERN(pattern: Integer) -> Bool,
        IS_D_PATTERN(pattern: Integer) -> Bool,
        IS_F_PATTERN(pattern: Integer) -> Bool,
        IS_PSK(n: Integer) -> Bool,
        GET_PSK_NAME() -> Integer,
    }

    /* 
    Explain why the encoding is sound and corresponds to the existential quantifier. 
    Also the assumptions we have on the oracle calls. 
    Duplciates are captured by Q for example! 
    Limitations of the tool and how we deal with not havign loop or set/list to capture , 
    and in other packages too (subtypes and bits(*))
    explanation of encoding of handles using their expected bahviour 
    
    Log^P,map:

    Log^Z = Log^Z,0
    Log^Z,inf
    Log^D,1
    Log^A = Log^A,0
    Log^A,1
    */

    oracle UNQ(n: Integer, h: Bits(*), hon: Bool, k: Bits(*)) -> Bits(*) {
        parameters <- invoke GET_LOG_PACKAGE_PARAMETERS(n);
        (pattern, mapping) <- parse parameters;
        psk_name <- invoke GET_PSK_NAME();

        /* mapping */
        is_infinity <- invoke IS_INFINITY_MAPPING(mapping);
        if is_infinity {
            if not hon {
                if (LogInverseDishonest[(n, k)] != None as Bits(*)) {
                    hp <- Unwrap(LogInverseDishonest[(n, k)]);
                    LogSetCheckpoint <- 1;
                    Log[(n, h)] <- Some((hp, hon, k));
                    return hp;
                }
            }
        }

        is_1_mapping <- invoke IS_1_MAPPING(mapping);
        if is_1_mapping {
            if not hon {
                if (J[k] != Some(true)) {
                    r <- Unwrap(level(h));
                    if (r == 0) {
                        if (LogInverseDishonestLevelNonZero[k] != None as Bits(*)) {
                            hp <- Unwrap(LogInverseDishonestLevelNonZero[k]);
                            LogInverseDishonestLevelZero[k] <- Some(h);
                            /* LogInverseDishonest[(psk_name, k)] <- Some(h); */
                            LogSetCheckpoint <- 2;
                            Log[(n, h)] <- Some((hp, hon, k));
                            J[k] <- Some(true);
                            return hp;
                        }
                    } else {
                        if (LogInverseDishonestLevelZero[k] != None as Bits(*)) {
                            hp <- Unwrap(LogInverseDishonestLevelZero[k]);
                            LogInverseDishonestLevelNonZero[k] <- Some(h);
                            /* LogInverseDishonest[(psk_name, k)] <- Some(h); */
                            LogSetCheckpoint <- 3;
                            Log[(n, h)] <- Some((hp, hon, k));
                            J[k] <- Some(true);
                            return hp;
                        }
                    }
                }
            }
        }

        /* pattern */
        is_A_pattern <- invoke IS_A_PATTERN(pattern);
        if is_A_pattern {
            r <- Unwrap(level(h));
            if ((r == 0) and not hon) {
                if (LogInverseDishonestLevelZero[k] != None as Bits(*)) {
                    assert false;
                }
            }
        }

        is_D_pattern <- invoke IS_D_PATTERN(pattern);
        if is_D_pattern {
            if not hon {
                if (LogInverseDishonest[(n, k)] != None as Bits(*)) {
                    assert false;
                }
            }
        }

        is_F_pattern <- invoke IS_F_PATTERN(pattern);
        if is_F_pattern {
            if (Seen[(n, k)] != None as Bool) { /* we are assuming UNQ is not called on the same inputs, Q will catch it */
                assert false;
            }
        }

        /* if the intention is to abort 
            when hon = 0 and hon' = 0 ? 
        alternatively
            hon = 0 or hon' = 0
            */

        Log[(n, h)] <- Some((h, hon, k));
        Seen[(n, k)] <- Some(true);
        if not hon {
            LogInverseDishonest[(n, k)] <- Some(h);
            is_psk <- invoke IS_PSK(n);
            if is_psk {
                r <- Unwrap(level(h));
                if (r == 0) {
                    LogInverseDishonestLevelZero[k] <- Some(h);
                } else {
                    LogInverseDishonestLevelNonZero[k] <- Some(h);
                }
            }
        }
        ReturnPoint <- 10;
        return h;
    }
    
    oracle Q(n: Integer, h: Bits(*)) -> Maybe(Bits(*)) {
        if (Log[(n, h)] == None) {
            return None;
        }
        (hp, hon, k) <- parse Unwrap(Log[(n, h)]);
        return Some(hp);
    }
}

