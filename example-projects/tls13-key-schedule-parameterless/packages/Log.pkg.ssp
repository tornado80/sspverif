package Log {
    /*
    types {
        Handle: Bits(*)
    }
    */

    params {
        /* pattern: Integer, /* pattern see README (shortly; Z: 0, A: 1, D: 2, F: 3) */
        /* mapping: Integer, /* mapping see README (shortly; 0: 0, 1: 1, inf: 2) */
        level: fn Bits(*) -> Integer /* returns the level of the given handle */
    }

    /*
    level(mk_dh_handle(X, Y)) = 0
    level(mk_xtr_handle(n, h1, h2)) = 1 + level(h1)
    */

    /* We need to show why choosing the first handle with the same key as in inverse of the key is okay */
    /* Review and illustrate the Log^Zinf recognizing collision and Map changes the mapping with an example attack scenario*/
    state {
        Log: Table((Integer, Bits(*)), (Bits(*), Bool, Bits(*))), /* maps (name, handle) to (mapped handle, honesty bit, key) */
        Seen: Table((Integer, Bits(*)), Bool), /* indicates whether the (name, key) was assigned before */
        LogInverseDishonest: Table((Integer, Bits(*)), Bits(*)), /* maps (name, key) to first dishonest handle */
        LogInverseDishonestLevelZero: Table((Integer, Bits(*)), Bits(*)), /* maps (name, key) to first dishonest handle in level zero */
        LogInverseDishonestLevelNonZero: Table((Integer, Bits(*)), Bits(*)), /* maps (name, key) to first dishonest handle in nonzero level */
        J: Table((Integer, Bits(*)), Bool) /* indicates whether the (name, key) was mapped before */
    }

    import oracles {
        GET_LOG_PACKAGE_PARAMETERS(n: Integer) -> (Integer, Integer),
    }

    /* 
    Explain why the encoding is sound and corresponds to the existential quantifier. 
    Also the assumptions we have on the oracle calls. 
    Duplciates are captured by Q for example! 
    Limitations of the tool and how we deal with not havign loop or set/list to capture , 
    and in other packages too (subtypes and bits(*))
    explanation of encoding of handles using their expected bahviour 
    
    Log^P,map:

    Log^Z = Log^Z,0
    Log^Z,inf
    Log^D,1
    Log^A = Log^A,0
    Log^A,1
    */

    oracle UNQ(n: Integer, h: Bits(*), hon: Bool, k: Bits(*)) -> Bits(*) {
        parameters <- invoke GET_LOG_PACKAGE_PARAMETERS(n);
        (pattern, mapping) <- parse parameters;

        /* mapping */
        if (mapping == 2) { /* infinity */
            if not hon {
                if (LogInverseDishonest[(n, k)] != None as Bits(*)) {
                    hp <- Unwrap(LogInverseDishonest[(n, k)]);
                    Log[(n, h)] <- Some((hp, hon, k));
                    J[(n, k)] <- Some(true);
                    return hp;
                }
            }
        }

        if (mapping == 1) { /* map = 1 */
            if not hon {
                if not Unwrap(J[(n, k)]) {
                    r <- level(h);
                    if (r == 0) {
                        if (LogInverseDishonestLevelNonZero[(n, k)] != None as Bits(*)) {
                            hp <- Unwrap(LogInverseDishonestLevelNonZero[(n, k)]);
                            Log[(n, h)] <- Some((hp, hon, k));
                            J[(n, k)] <- Some(true);
                            return hp;
                        }
                    } else {
                        if (LogInverseDishonestLevelZero[(n, k)] != None as Bits(*)) {
                            hp <- Unwrap(LogInverseDishonestLevelZero[(n, k)]);
                            Log[(n, h)] <- Some((hp, hon, k));
                            J[(n, k)] <- Some(true);
                            return hp;
                        }
                    }
                }
            }
        }

        /* pattern */
        if (pattern == 1)  { /* A */
            if not hon {
                if (LogInverseDishonestLevelZero[(n, k)] != None as Bits(*)) {
                    assert false;
                }
            }
        }

        if (pattern == 2)  { /* D */
            if not hon {
                if (LogInverseDishonest[(n, k)] != None as Bits(*)) {
                    assert false;
                }
            }
        }

        if (pattern == 3)  { /* F */
            if (Seen[(n, k)] != None as Bool) { /* we are assuming UNQ is not called on the same inputs, Q will catch it */
                assert false;
            }
        }

        /* if the intention is to abort 
            when hon = 0 and hon' = 0 ? 
        alternatively
            hon = 0 or hon' = 0
            */

        Log[(n, h)] <- Some((h, hon, k));
        Seen[(n, k)] <- Some(true);
        if not hon {
            LogInverseDishonest[(n, k)] <- Some(h);
            r <- level(h);
            if (r == 0) {
                LogInverseDishonestLevelZero[(n, k)] <- Some(h);
            } else {
                LogInverseDishonestLevelNonZero[(n, k)] <- Some(h);
            }
        }
        return h;
    }
    
    oracle Q(n: Integer, h: Bits(*)) -> Maybe(Bits(*)) {
        if (Log[(n, h)] == None) {
            return None;
        }
        (hp, hon, k) <- parse Unwrap(Log[(n, h)]);
        return Some(hp);
    }
}

