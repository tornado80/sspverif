proof Proof {
    const b: Bool;

    /*
    const secret_key_length: 1000;
    const public_key_length: 100;
    const output_key_length: 256;
    const encapsulation_length: 400;
    const gen_randomness_length: 2000;
    const enc_randomness_length: 500; should depend on message length
    */

    const len: fn Bits(*) -> Integer;
    const zeros: fn Integer -> Bits(*);
    const concatenate: fn Bits(400), Bits(*) -> Bits(*);
    const deconcatenate: fn Bits(*) -> (Bits(400), Bits(*));
    const kem_gen: fn Bits(2000) -> (Bits(100), Bits(1000));
    const kem_encaps: fn Bits(100) -> (Bits(256), Bits(400));
    const kem_decaps: fn Bits(1000), Bits(400) -> Bits(256);
    const dem_enc: fn Bits(500), Bits(256), Bits(*) -> Bits(*);
    const dem_dec: fn Bits(256), Bits(*) -> Bits(*);

    instance monolithic_pke_cca_game = MonolithicPkeCcaGame {
        params {
            b: b,
            len: len,
            zeros: zeros,
            concatenate: concatenate,
            deconcatenate: deconcatenate,
            kem_gen: kem_gen,
            kem_encaps: kem_encaps,
            kem_decaps: kem_decaps,
            dem_enc: dem_enc,
            dem_dec: dem_dec,
        }
    }

    instance modular_pke_cca_game_with_real_kem = ModularPkeCcaGame {
        params {
            kem_idealization: false,
            dem_idealization: b,
            len: len,
            zeros: zeros,
            concatenate: concatenate,
            deconcatenate: deconcatenate,
            kem_gen: kem_gen,
            kem_encaps: kem_encaps,
            kem_decaps: kem_decaps,
            dem_enc: dem_enc,
            dem_dec: dem_dec,
        }
    }

    instance monolithic_pke_cca_real_game = MonolithicPkeCcaGame {
        params {
            b: false,
            len: len,
            zeros: zeros,
            concatenate: concatenate,
            deconcatenate: deconcatenate,
            kem_gen: kem_gen,
            kem_encaps: kem_encaps,
            kem_decaps: kem_decaps,
            dem_enc: dem_enc,
            dem_dec: dem_dec,
        }
    }

    instance monolithic_pke_cca_ideal_game = MonolithicPkeCcaGame {
        params {
            b: true,
            len: len,
            zeros: zeros,
            concatenate: concatenate,
            deconcatenate: deconcatenate,
            kem_gen: kem_gen,
            kem_encaps: kem_encaps,
            kem_decaps: kem_decaps,
            dem_enc: dem_enc,
            dem_dec: dem_dec,
        }
    }

    instance modular_pke_cca_game_with_real_kem_and_real_dem = ModularPkeCcaGame {
        params {
            kem_idealization: false,
            dem_idealization: false,
            len: len,
            zeros: zeros,
            concatenate: concatenate,
            deconcatenate: deconcatenate,
            kem_gen: kem_gen,
            kem_encaps: kem_encaps,
            kem_decaps: kem_decaps,
            dem_enc: dem_enc,
            dem_dec: dem_dec,
        }
    }

    instance modular_pke_cca_game_with_ideal_kem_and_real_dem = ModularPkeCcaGame {
        params {
            kem_idealization: true,
            dem_idealization: false,
            len: len,
            zeros: zeros,
            concatenate: concatenate,
            deconcatenate: deconcatenate,
            kem_gen: kem_gen,
            kem_encaps: kem_encaps,
            kem_decaps: kem_decaps,
            dem_enc: dem_enc,
            dem_dec: dem_dec,
        }
    }

    instance modular_pke_cca_game_with_real_kem_and_ideal_dem = ModularPkeCcaGame {
        params {
            kem_idealization: false,
            dem_idealization: true,
            len: len,
            zeros: zeros,
            concatenate: concatenate,
            deconcatenate: deconcatenate,
            kem_gen: kem_gen,
            kem_encaps: kem_encaps,
            kem_decaps: kem_decaps,
            dem_enc: dem_enc,
            dem_dec: dem_dec,
        }
    }

    instance modular_pke_cca_game_with_ideal_kem_and_ideal_dem = ModularPkeCcaGame {
        params {
            kem_idealization: true,
            dem_idealization: true,
            len: len,
            zeros: zeros,
            concatenate: concatenate,
            deconcatenate: deconcatenate,
            kem_gen: kem_gen,
            kem_encaps: kem_encaps,
            kem_decaps: kem_decaps,
            dem_enc: dem_enc,
            dem_dec: dem_dec,
        }
    }

    instance dem_cca_game_real = DemCcaGame {
        params {
            b: false,
            len: len,
            zeros: zeros,
            dem_enc: dem_enc,
            dem_dec: dem_dec,
        }
    }

    instance dem_cca_game_ideal = DemCcaGame {
        params {
            b: true,
            len: len,
            zeros: zeros,
            dem_enc: dem_enc,
            dem_dec: dem_dec,
        }
    }

    instance kem_cca_game_real = KemCcaGame {
        params {
            b: false,
            kem_gen: kem_gen,
            kem_encaps: kem_encaps,
            kem_decaps: kem_decaps,
        }
    }

    instance kem_cca_game_ideal = KemCcaGame {
        params {
            b: true,
            kem_gen: kem_gen,
            kem_encaps: kem_encaps,
            kem_decaps: kem_decaps,
        }
    }

    assumptions {
        KEM_CCA_Security: kem_cca_game_real ~ kem_cca_game_ideal
        DEM_CCA_Security: dem_cca_game_real ~ dem_cca_game_ideal
    }

    gamehops {
        /* 
        We want to prove PKE-CCA security of the KEM-DEM construction described in the packages 
        reduce to KEM-CCA and DEM-CCA security of underlying KEM and DEM schemes.
        Therefore, we want to bound distinguishing advantage of an arbitrary adversary between real and ideal monolithic PKE-CCA games.
        We do 5 game hops to reach monolithic_pke_cca_game_ideal from monolithic_pke_cca_game_real.
        These 5 game hops are aligned in order below.
        The first and last hops are each between perfectly indistinguishable games.
        They are proved as code equivalence steps or game hops on pen and paper proofs.
        SSBee helps to automate checking the equivalence of games by "inlining" oracles and translating their code to SMT-LIB language and uses an SMT solver to automate the check.
        The three middle hops are each between computationally indistinguishable games.
        We reduce the indistinguishability of these games by graph cuts to the indistinguishability stated in our assumptions. (either KEM-CCA or DEM-CCA games) 
        Graph cuts demonstarte intuitive and visual reductions possible in SSP framework.
        SSBee helps to communicate graph cuts more formally and precisely throught mapping.
        The core idea is that we need to identify which instances should be put together to form the reduction package. The rest of instances of the game should constitute the assumption games.
        SSBee algorithimically verifies this using the annotated call/dependecy graph of the compostion by matching the types of the mapped packages and their parameters as well as verifying a single reduction package can be used to split the left and right games to those of the assumption.
        */
        /* We first prove real PKE-CCA game is equivalent to the modular version (i.e. modular_pke_cca_game_with_real_kem_and_real_dem) */

        equivalence monolithic_pke_cca_real_game modular_pke_cca_game_with_real_kem_and_real_dem {
            PKGEN: {
                invariant: [
                    ./proofs/invariant.smt2
                ]

                lemmas {
                    invariant: [no-abort]
                    same-output: [no-abort]
                    equal-aborts: []
                }
            }

            PKENC: {
                invariant: [
                    ./proofs/invariant.smt2
                ]

                lemmas {
                    invariant: [no-abort]
                    same-output: [no-abort]
                    equal-aborts: []
                }
            }

            PKDEC: {
                invariant: [
                    ./proofs/invariant.smt2
                ]

                lemmas {
                    invariant: [no-abort]
                    same-output: [no-abort]
                    equal-aborts: []
                }
            }
        }

        /* Now we hop three times to reach modular_pke_cca_game_with_real_kem_and_ideal_dem */
        /* First hop idealizes KEM and reduces to KEM-CCA security */
        /*
        reduction modular_pke_cca_game_with_real_kem_and_real_dem modular_pke_cca_game_with_ideal_kem_and_real_dem {
            assumption KEM_CCA_Security

            map kem_cca_game_real modular_pke_cca_game_with_real_kem_and_real_dem {
                pkg_KemScheme: pkg_KemScheme
                pkg_Key: pkg_Key
                pkg_KEM: pkg_KEM
            }

            map kem_cca_game_ideal modular_pke_cca_game_with_ideal_kem_and_real_dem {
                pkg_KemScheme: pkg_KemScheme
                pkg_Key: pkg_Key
                pkg_KEM: pkg_KEM
            }
        }
        */

        /* Second hop idealizes DEM and reduces to DEM-CCA security */
        /*
        reduction modular_pke_cca_game_with_ideal_kem_and_real_dem modular_pke_cca_game_with_ideal_kem_and_ideal_dem {
            assumption DEM_CCA_Security

            map dem_cca_game_real modular_pke_cca_game_with_ideal_kem_and_real_dem {
                pkg_DemScheme: pkg_DemScheme
                pkg_Key: pkg_Key
                pkg_DEM: pkg_DEM
            }

            map dem_cca_game_ideal modular_pke_cca_game_with_ideal_kem_and_ideal_dem {
                pkg_DemScheme: pkg_DemScheme
                pkg_Key: pkg_Key
                pkg_DEM: pkg_DEM
            }
        }
        */

        /* Third hop deidealizes KEM and reduces to KEM-CCA security again */
        /*
        reduction modular_pke_cca_game_with_ideal_kem_and_ideal_dem modular_pke_cca_game_with_real_kem_and_ideal_dem {
            assumption KEM_CCA_Security

            map kem_cca_game_real modular_pke_cca_game_with_ideal_kem_and_ideal_dem {
                pkg_KemScheme: pkg_KemScheme
                pkg_Key: pkg_Key
                pkg_KEM: pkg_KEM
            }

            map kem_cca_game_ideal modular_pke_cca_game_with_real_kem_and_ideal_dem {
                pkg_KemScheme: pkg_KemScheme
                pkg_Key: pkg_Key
                pkg_KEM: pkg_KEM
            }
        }
        */

        /* We have finally reached our destination (namely modular_pke_cca_game_with_real_kem_and_ideal_dem) */
        /* We now prove the ideal PKE-CCA game  */
        equivalence monolithic_pke_cca_ideal_game modular_pke_cca_game_with_real_kem_and_ideal_dem {
            PKGEN: {
                invariant: [
                    ./proofs/invariant.smt2
                ]

                lemmas {
                    invariant: [no-abort]
                    same-output: [no-abort]
                    equal-aborts: []
                }
            }

            PKENC: {
                invariant: [
                    ./proofs/invariant.smt2
                ]

                lemmas {
                    invariant: [no-abort]
                    same-output: [no-abort]
                    equal-aborts: []
                }
            }

            PKDEC: {
                invariant: [
                    ./proofs/invariant.smt2
                ]

                lemmas {
                    invariant: [no-abort]
                    same-output: [no-abort]
                    equal-aborts: []
                }
            }
        }

        /* 
        Instead of previous equivalence goals, we can concisely prove the following equivalence in one go.
        Note that both games are initialized using the same idealization bit "b" (i.e. left_b = right_dem_initialization).
        */

        equivalence monolithic_pke_cca_game modular_pke_cca_game_with_real_kem {
            PKGEN: {
                invariant: [
                    ./proofs/invariant.smt2
                ]

                lemmas {
                    invariant: [no-abort]
                    same-output: [no-abort]
                    equal-aborts: []
                }
            }

            PKENC: {
                invariant: [
                    ./proofs/invariant.smt2
                ]

                lemmas {
                    invariant: [no-abort]
                    same-output: [no-abort]
                    equal-aborts: []
                }
            }

            PKDEC: {
                invariant: [
                    ./proofs/invariant.smt2
                ]

                lemmas {
                    invariant: [no-abort]
                    same-output: [no-abort]
                    equal-aborts: []
                }
            }
        }
    }


}