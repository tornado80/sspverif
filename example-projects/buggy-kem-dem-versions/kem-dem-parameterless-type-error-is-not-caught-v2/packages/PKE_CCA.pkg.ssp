package PKE_CCA {
    params {
        b: Bool,
        len: fn Bits(*) -> Integer,
        zeros: fn Integer -> Bits(*),
    }

    import oracles {
        GEN() -> (Bits(100), Bits(1000)),
        ENC(pk: Bits(100), m: Bits(*)) -> Bits(*) /* ciphertext length */,
        DEC(sk: Bits(1000), c: Bits(*) /* ciphertext length */) -> Bits(*),
    }

    state {
        pk: Maybe(Bits(100)),
        sk: Maybe(Bits(1000)),
        c: Maybe(Bits(*))
    }

    oracle PKGEN() -> Bits(100) {
        assert (sk == None);
        pk_sk <- invoke GEN();
        (pk1, sk1) <- parse pk_sk;
        pk <- Some(pk1);
        sk <- Some(sk1);
        return pk1;
    }

    oracle PKENC(m: Bits(*)) -> Bits(*) {
        assert (pk != None as Bits(100));
        assert (c == None);
        if b {
            c1 <- invoke ENC(Unwrap(pk), zeros(len(m)));
        } else {
            c1 <- invoke ENC(Unwrap(pk), m);
        }
        c <- Some(c1);
        return c1;
    }

    oracle PKDEC(ctxt: Bits(*)) -> Bits(*) {
        assert (sk != None as Bits(1000));
        assert (Unwrap(c) != ctxt);
        m <- invoke DEC(Unwrap(sk), ctxt);
        return m;
    }
}